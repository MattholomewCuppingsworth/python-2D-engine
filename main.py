import pygame, random

#Window Size constant
size = (800, 600)


#Components
class Position:
	def __init__(self, x, y):
		self.x = x
		self.y = y
	def update(self, dx, dy):
		self.x += dx
		self.y += dy

class Movement:
	def __init__(self, dx, dy):
		self.dy = dy
		self.dx = dx

class Graphic(pygame.sprite.Sprite):
	def __init__(self, width, height, image):
		pygame.sprite.Sprite.__init__(self)
		self.image = pygame.Surface([width, height])
		self.image.blit(image, (0,0))



#Entities
class Character:
	def __init__(self, frames, position, movement):
		self.frames = frames
		self.position = position
		self.movement = movement



#Tools (To be moved to a util file later)
class SpriteSheet(object):
	def __init__(self, filename):
		try:
			self.sheet = pygame.image.load(filename).convert()
		except pygame.error, message:
			print 'Unable to load spritesheet image:', filename
			raise SystemExit, message
	# Load a specific image from a specific rectangle
	def image_at(self, rectangle, colorkey = None):
		"Loads image from x,y,x+offset,y+offset"
		rect = pygame.Rect(rectangle)
		image = pygame.Surface(rect.size).convert()
		image.blit(self.sheet, (0, 0), rect)
		if colorkey is not None:
			if colorkey is -1:
				colorkey = image.get_at((0,0))
				image.set_colorkey(colorkey, pygame.RLEACCEL)
				return image
	# Load a whole bunch of images and return them as a list
	def images_at(self, rects, colorkey = None):
		"Loads multiple images, supply a list of coordinates" 
		return [self.image_at(rect, colorkey) for rect in rects]
	# Load a whole strip of images
	def load_strip(self, rect, image_count, colorkey = None):
		"Loads a strip of images and returns them as a list"
		tups = [(rect[0]+rect[2]*x, rect[1], rect[2], rect[3])
				for x in range(image_count)]
		return self.images_at(tups, colorkey)


class FrameIter: #iterates through a list of graphics
	def __init__(self, images, loop = False, frames = 1):
		"""construct a SpriteStripAnim
		
		images is a list of images generated by load_strip

		loop is a boolean that, when True, causes the next() method to
		loop. If False, the terminal case raises StopIteration.
		
		frames is the number of ticks to return the same image before
		the iterator advances to the next image.
		"""
		self.i = 0
		self.loop = loop
		self.images = images
		self.frames = frames
		self.f = frames
	def iter(self):
		self.i = 0
		self.f = self.frames
		return self
	def next(self):
		if self.i >= len(self.images):
			if not self.loop:
				raise StopIteration
			else:
				self.i = 0
		image = self.images[self.i]
		self.f -= 1
		if self.f == 0:
			self.i += 1
			self.f = self.frames
		return image
	def __add__(self, ss):
		self.images.extend(ss.images)
		return self




def main():
	pygame.init()
	screen = pygame.display.set_mode(size)
	pygame.display.set_caption("Whoa, this is a nice window, guy!")
	clock = pygame.time.Clock()
	done = False

	char_sprites = SpriteSheet("./sprites.png")

	blueHairedBack = char_sprites.load_strip((0,128,24,32), 3, -1)
	blueHairedRight = char_sprites.load_strip((0,160,24,32), 3, -1)
	blueHairedForward = char_sprites.load_strip((0,192,24,32), 3, -1)
	blueHairedLeft = char_sprites.load_strip((0,224,24,32), 3, -1)

	gogglesBack = char_sprites.load_strip((144,0,24,32), 3, -1)
	gogglesRight = char_sprites.load_strip((144,32,24,32), 3, -1)
	gogglesForward = char_sprites.load_strip((144,64,24,32), 3, -1)
	gogglesLeft = char_sprites.load_strip((144,96,24,32), 3, -1)
	
	frames = 5
	frameIter = FrameIter(gogglesBack, True, frames)

	mainDude = Character(frameIter, Position(size[0]/2,size[1]/2), Movement(0,0))
	moving = False

	while(not done):	#game loop
		#	For each event (keypress, mouse click, etc.):
		for event in pygame.event.get(): # User did something
			keys = pygame.key.get_pressed()
			#	Use a chain of if statements to run code to handle each event.
			if event.type == pygame.QUIT: # If user clicked close
				done = True # Flag that we are done so we exit this loop
			elif event.type == pygame.KEYDOWN: # 
				if(keys[pygame.K_ESCAPE]):
					print "We're outta here!"
					done = True
				if(keys[pygame.K_UP]):
					mainDude.movement.dy = -2
					moving = True
				if(keys[pygame.K_DOWN]):
					mainDude.movement.dy = 2
					moving = True
				if(keys[pygame.K_LEFT]):
					mainDude.movement.dx = -2
					moving = True
				if(keys[pygame.K_RIGHT]):
					mainDude.movement.dx = 2
					moving = True
			elif event.type == pygame.KEYUP:
				# Up or down is still pressed, stop left and right movement
				if (keys[pygame.K_DOWN] or keys[pygame.K_UP]):
					mainDude.movement.dx = 0
				# vica versa
				elif (keys[pygame.K_LEFT] or keys[pygame.K_RIGHT]):
					mainDude.movement.dy = 0
				# no keys are pressed, stop it all
				else:
					mainDude.movement.dx = 0
					mainDude.movement.dy = 0
					moving = False
			elif event.type == pygame.MOUSEMOTION:
				location = pygame.mouse.get_pos()
				print location
			elif event.type == pygame.MOUSEBUTTONDOWN:
				print "whoa buddy, lay off"
			elif event.type == pygame.MOUSEBUTTONUP:
				print "thanks, geez. Stop it then."

		#	Run calculations to determine where objects move, what happens when objects collide, etc.
		mainDude.position.update(mainDude.movement.dx, mainDude.movement.dy)

		if(mainDude.movement.dx > 0):
			mainDude.frames.images = gogglesRight
		elif(mainDude.movement.dx < 0):
			mainDude.frames.images = gogglesLeft
		if(mainDude.movement.dy > 0):
			mainDude.frames.images = gogglesForward
		elif(mainDude.movement.dy < 0):
			mainDude.frames.images = gogglesBack

		#	Clear the screen
		screen.fill((1,1,1))

		#	Draw everything
		if moving:
			screen.blit(mainDude.frames.next(), (mainDude.position.x, mainDude.position.y))
		else:
			screen.blit(mainDude.frames.images[0], (mainDude.position.x, mainDude.position.y))


		pygame.display.update()

		msElapsed = clock.tick(30) #advances frame, 30 FPS

if __name__ == '__main__' : main()